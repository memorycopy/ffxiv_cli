[Êü•Áúã‰∏≠ÊñáÁâàÊú¨ (View in Chinese)](README_CN.md)

# FFXIV Combat Simulator

This project is a Python-based combat simulator for Final Fantasy XIV, designed to analyze job rotations and estimate damage output. It currently features a detailed simulation for the Samurai job, with tools for Monte Carlo analysis and visualization of DPS and total damage over time.

## Project Philosophy ü§î

The core principle of this project is to provide a robust engine for **calculation and analysis** of FFXIV combat scenarios. It is not intended to be a tool for creating beautiful visualizations or an automated rotation planner for optimization. Users who require such features are encouraged to build their own GUI or analysis tools on top of the simulation core provided here.

## Project Structure

- `main.py`: Main script to run simulations. It demonstrates setting up a character, running a Samurai rotation, and analyzing the results.
- `montecarlo.py`: Provides utilities for Monte Carlo simulations, offering different strategies (standard, parallel, memory-efficient) for damage distribution analysis.
- `convert_rotation.py`: A script to convert action sequences from a text file format to the JSON format used by the simulator. THIS is mainly used for reading my old rotation data which was saved in txt format. Write your old adator if you want to load data from other sources.
- `xivcore/`: This directory contains the core logic for the simulation.
    - `core.py`: Core simulation engine, handling events, character states, and combat mechanics.
    - `common.py`: Common data structures and utilities, such as character gear sets and action definitions.
    - `xivstats.py`: Likely contains statistical models or data related to FFXIV combat.
    - `task.py`: Defines task structures for the simulation.
    - `job/`: Contains implementations for specific FFXIV jobs.
        - `samurai.py`: Detailed implementation for the Samurai job.
        - Other files (e.g., `blackmage.py`, `ninja.py`) are placeholders for future job implementations.
- `rotations/`: Contains JSON files defining character gear sets and rotations used in simulations (e.g., `sam_820.json`).
- `dps_over_time.png`, `total_damage_over_time.png`: Example plots generated by the simulation.

## Features

- **Combat Simulation**: Simulates FFXIV combat scenarios, focusing on job rotations.
- **Job Support**: Includes a detailed implementation for the jobs (currently only SAM).
- **Monte Carlo Analysis**: Uses Monte Carlo methods to analyze damage distributions and estimate DPS.
- **Multiple Simulation Strategies**: Offers standard, parallel, and memory-efficient simulation methods.
- **DPS Visualization**: Generates plots for DPS over time and total damage over time.
- **Rotation Conversion**: Provides a script to convert rotations from a simple text format to JSON.
- **Multiplayer Simulation**: Supports simulating combat scenarios with multiple players interacting within the same environment.

## Supported Jobs ‚öîÔ∏è

- **Samurai (SAM)**: Fully implemented and the primary focus of current simulations. ‰æç
- Other jobs (e.g., Black Mage ‚ú®, Ninja ü•∑, Viper üêç, Pictomancer üé®): Placeholders exist, planned for future development.

## Example Output üìä

Here's an example of the DPS over time plot generated by the simulator:

![DPS Over Time](dps_over_time.png)

## How to Run

1.  **Define a rotation**: Rotations can be defined in a text file and converted to JSON using `convert_rotation.py`, or directly created as a JSON file in the `rotations/` directory.
2.  **Configure the simulation**: Modify `main.py` to specify the character, gear set, rotation file, and simulation parameters (e.g., fight duration, number of simulations).
3.  **Run the simulation**: Execute `main.py`:
    ```bash
    python main.py
    ```
4.  **View results**: The script will output DPS statistics and generate plots (`dps_over_time.png`, `total_damage_over_time.png`).

## Custom Simulation Setup Example üõ†Ô∏è

Here's a basic example of how to set up a custom simulation with a player and an enemy:

```python
import xivcore.job
from xivcore.common import CharacterGearset
from xivcore.core import Arena, Player, BattleCharacter, Rotation

# Simulation parameters
SIMULATION_TIME_MS = 5 * 60 * 1000  # 5 minutes
ROTATION_FILE_PATH = "rotations/sam_820.json" # Example Samurai rotation

# 1. Initialize the Arena (simulation world)
# Start 30 seconds before combat for pre-pull actions
world = Arena(time=-30000)

# 2. Create and configure player(s)
# Load gearset from a rotation JSON (can also be defined manually)
gearset = CharacterGearset.from_rotation_json(ROTATION_FILE_PATH)
player1 = Player(entity_id=1, gearset=gearset)

# Register job-specific actions (e.g., Samurai)
xivcore.job.register_common_actions(player1)
xivcore.job.samurai.register_samurai_actions(player1) # Replace with other jobs as needed

# Add player to the world
world.add_player(player1)

# (Optional) Add more players for multiplayer simulation
# gearset_player2 = ...
# player2 = Player(entity_id=3, gearset=gearset_player2)
# xivcore.job.register_common_actions(player2)
# xivcore.job.ninja.register_ninja_actions(player2) # Example for a Ninja
# world.add_player(player2)

# 3. Create and configure enemy/boss(es)
# Simple dummy target
enemy1 = BattleCharacter(entity_id=2)
world.add_enemy(enemy1)

# (Optional) Add more enemies
# enemy2 = BattleCharacter(entity_id=4, hp=1000000) # Enemy with specific HP
# world.add_enemy(enemy2)

# 4. Start server ticks (important for DoTs and other timed effects)
world.start_server_tick()

# 5. Define and assign rotation to player(s)
rotation1 = Rotation.load_from_json(ROTATION_FILE_PATH)
player1.set_rotation(rotation1)
# For multiplayer, assign rotations to other players as well

# 6. Set targets and start rotations
player1.set_target(enemy1)
player1.start_rotation()
# For multiplayer, set targets for other players (they can target same or different enemies)
# player2.set_target(enemy1)
# player2.start_rotation()

# 7. Run the simulation
print(f"Starting custom simulation for {SIMULATION_TIME_MS / 1000} seconds...")
world.step(frame_delta=SIMULATION_TIME_MS - world.current_time)
print("Simulation finished.")

# 8. Analyze results (e.g., inspect enemy1.damage_taken)
# (Refer to main.py or montecarlo.py for more detailed analysis examples)
for i, record in enumerate(enemy1.damage_taken):
    print(f"[{i:03d}] {record}")

# For Monte Carlo analysis, you would typically collect damage_taken from the enemy
# after one simulation run (like above, but often shorter for generating a baseline log),
# and then feed that into the MonteCarloSimulator.
```

This example provides a starting point. You can expand upon it to create more complex scenarios with multiple players, different jobs, multiple enemies, and custom event handling if needed. Refer to `main.py` and `montecarlo.py` for more advanced usage and analysis techniques.

## Future Development Directions

- Implementations for other FFXIV jobs (Black Mage ‚ú®, Ninja ü•∑, Viper üêç, Pictomancer üé®, and more!) 
    - ```If I have time and are willing to. Don't look forward to. DIY üòÖüõ†Ô∏è```.
- More sophisticated statistical analysis and reporting.
- GUI for easier configuration and result visualization. 

## Author

- memcpy@Á∫¢ÁéâÊµ∑

## Credits üôè

- Formulas and Data(Modifiers, etc) from **Allagan Studies** community: their invaluable resources and in-depth analysis of FFXIV game mechanics, which have been a great reference for this project. 
- The gearset stats calculation logic is inspired by and references code from [Asvel/ffxiv-gearing](https://github.com/Asvel/ffxiv-gearing). 

## License üìÑ

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.